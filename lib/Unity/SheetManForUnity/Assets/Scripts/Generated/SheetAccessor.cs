// ------------------------------------------------------------------------------
// <auto-generated>
//     THIS CODE WAS GENERATED BY SheetMan.
//
//     CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
//     THE CODE IS REGENERATED.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

using SheetMan.Runtime;

#if !NO_UNITY
using Cysharp.Threading.Tasks;
#endif

namespace StaticData
{
    #region Static tables
    public partial class Tables
    {
        public delegate Task<byte[]> ReadAllBytesAsyncDelegate(string filename);

        public static ReadAllBytesAsyncDelegate ReadAllBytesAsync = async (string filename) => {
        #if !NO_UNITY
            byte[] bytes = null;
            await Task.Run(() => {
                bytes = File.ReadAllBytes(filename);
            });

            return bytes;
        #else
            var bytes = await System.IO.File.ReadAllBytesAsync(filename);
            if (bytes == null)
                throw new SheetManException($"Cannot read a file '{filename}'");

            return bytes;
        #endif
        };

        /// <summary>
        /// Property for Localization table.
        /// </summary>
        public static LocalizationTable Localization { get; private set; }

        /// <summary>
        /// Property for TestFieldTypes table.
        /// </summary>
        public static TestFieldTypesTable TestFieldTypes { get; private set; }

        /// <summary>
        /// Property for SerialFields table.
        /// </summary>
        public static SerialFieldsTable SerialFields { get; private set; }

        /// <summary>
        /// Read all tables.
        /// </summary>
        public static async Task ReadAllAsync(string basePath, string fileExtension = ".table")
        {
            var tasks = new List<Task>();

            Localization = new LocalizationTable();
            tasks.Add(Localization.ReadAsync(System.IO.Path.Combine(basePath, $"Localization{fileExtension}")));

            TestFieldTypes = new TestFieldTypesTable();
            tasks.Add(TestFieldTypes.ReadAsync(System.IO.Path.Combine(basePath, $"TestFieldTypes{fileExtension}")));

            SerialFields = new SerialFieldsTable();
            tasks.Add(SerialFields.ReadAsync(System.IO.Path.Combine(basePath, $"SerialFields{fileExtension}")));

            await Task.WhenAll(tasks);

            SolveCrossReferences();
        }

        /// <summary>
        /// Solve cross references.
        /// </summary>
        private static void SolveCrossReferences()
        {
        }
    }
    #endregion

    #region LocalizationTable
    /// <summary>
    /// 로컬라이제이션 테이블입니다.
    /// </summary>
    [System.Serializable]
    public partial class LocalizationTable
    {
        #region Record
        [System.Serializable]
        public partial class Record
        {
            #region Fields
            /// <summary>
            /// 인덱스(필수)
            /// </summary>
            public int Index => _index;
            private int _index;

            /// <summary>
            /// 스트링 키
            /// </summary>
            public string Key => _key;
            private string _key;

            /// <summary>
            /// 설명
            /// </summary>
            public string Description => _description;
            private string _description;

            /// <summary>
            /// 영어
            /// </summary>
            public string English => _english;
            private string _english;

            /// <summary>
            /// 한글
            /// </summary>
            public string Korean => _korean;
            private string _korean;

            /// <summary>
            /// 스페니시
            /// </summary>
            public string Spanish => _spanish;
            private string _spanish;

            /// <summary>
            /// 중국어
            /// </summary>
            public string Chinese => _chinese;
            private string _chinese;

            /// <summary>
            /// 프랑스어
            /// </summary>
            public string French => _french;
            private string _french;

            /// <summary>
            /// 독일어
            /// </summary>
            public string German => _german;
            private string _german;

            /// <summary>
            /// 인도네시아어
            /// </summary>
            public string Indonesian => _indonesian;
            private string _indonesian;

            /// <summary>
            /// 일본어
            /// </summary>
            public string Japanese => _japanese;
            private string _japanese;

            /// <summary>
            /// 포루투칼어
            /// </summary>
            public string Portuguese => _portuguese;
            private string _portuguese;

            /// <summary>
            /// 러시아어
            /// </summary>
            public string Russian => _russian;
            private string _russian;

            /// <summary>
            /// 베트남어
            /// </summary>
            public string Vietnamese => _vietnamese;
            private string _vietnamese;
            #endregion

            #region Read record
            /// <summary>
            /// Reads a table record.
            /// </summary>
            public Task ReadAsync(LiteBinaryReader reader)
            {
                reader.Read(out _index);

                reader.Read(out _key);

                reader.Read(out _description);

                reader.Read(out _english);

                reader.Read(out _korean);

                reader.Read(out _spanish);

                reader.Read(out _chinese);

                reader.Read(out _french);

                reader.Read(out _german);

                reader.Read(out _indonesian);

                reader.Read(out _japanese);

                reader.Read(out _portuguese);

                reader.Read(out _russian);

                reader.Read(out _vietnamese);

                return Task.CompletedTask;
            }
            #endregion

            #region ToString
            public override string ToString()
            {
                var sb = new StringBuilder("{");
                sb.Append("\"Index\":"); ToStringHelper.ToString(Index, sb);
                sb.Append(",\"Key\":"); ToStringHelper.ToString(Key, sb);
                sb.Append(",\"Description\":"); ToStringHelper.ToString(Description, sb);
                sb.Append(",\"English\":"); ToStringHelper.ToString(English, sb);
                sb.Append(",\"Korean\":"); ToStringHelper.ToString(Korean, sb);
                sb.Append(",\"Spanish\":"); ToStringHelper.ToString(Spanish, sb);
                sb.Append(",\"Chinese\":"); ToStringHelper.ToString(Chinese, sb);
                sb.Append(",\"French\":"); ToStringHelper.ToString(French, sb);
                sb.Append(",\"German\":"); ToStringHelper.ToString(German, sb);
                sb.Append(",\"Indonesian\":"); ToStringHelper.ToString(Indonesian, sb);
                sb.Append(",\"Japanese\":"); ToStringHelper.ToString(Japanese, sb);
                sb.Append(",\"Portuguese\":"); ToStringHelper.ToString(Portuguese, sb);
                sb.Append(",\"Russian\":"); ToStringHelper.ToString(Russian, sb);
                sb.Append(",\"Vietnamese\":"); ToStringHelper.ToString(Vietnamese, sb);
                sb.Append("}");
                return sb.ToString();
            }
            #endregion
        }
        #endregion

        /// <summary>
        /// Field names.
        /// </summary>
        public static readonly string[] FieldNames = { "Index", "Key", "Description", "English", "Korean", "Spanish", "Chinese", "French", "German", "Indonesian", "Japanese", "Portuguese", "Russian", "Vietnamese" };

        /// <summary>
        /// Build object value map.
        /// </summary>
        public List<object[]> BuildObjectValueMap()
        {
            var result = new List<object[]>();
            foreach (var r in _records)
                result.Add(new object[] { r.Index, r.Key, r.Description, r.English, r.Korean, r.Spanish, r.Chinese, r.French, r.German, r.Indonesian, r.Japanese, r.Portuguese, r.Russian, r.Vietnamese });

            return result;
        }

        /// <summary>
        /// All records.
        /// </summary>
        public List<Record> Records => _records;
        private readonly List<Record> _records = new List<Record>();

        #region Indexing by 'Index'
        public Dictionary<int, Record> RecordsByIndex => _recordsByIndex;
        private readonly Dictionary<int, Record> _recordsByIndex = new Dictionary<int, Record>();

        /// <summary>
        /// Gets the value associated with the specified key. throw SheetManException if not found.
        /// </summary>
        public Record GetByIndex(int key)
        {
            if (!TryGetByIndex(key, out Record record))
                throw new SheetManException($"There is no record in table `Localization` that corresponds to field `Index` value {key}");

            return record;
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        public bool TryGetByIndex(int key, out Record result) => _recordsByIndex.TryGetValue(key, out result);

        /// <summary>
        /// Determines whether the table contains the specified key.
        /// </summary>
        public bool ContainsIndex(int key) => _recordsByIndex.ContainsKey(key);
        #endregion // Indexing by `Index`

        #region Indexing by 'Key'
        public Dictionary<string, Record> RecordsByKey => _recordsByKey;
        private readonly Dictionary<string, Record> _recordsByKey = new Dictionary<string, Record>();

        /// <summary>
        /// Gets the value associated with the specified key. throw SheetManException if not found.
        /// </summary>
        public Record GetByKey(string key)
        {
            if (!TryGetByKey(key, out Record record))
                throw new SheetManException($"There is no record in table `Localization` that corresponds to field `Key` value {key}");

            return record;
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        public bool TryGetByKey(string key, out Record result) => _recordsByKey.TryGetValue(key, out result);

        /// <summary>
        /// Determines whether the table contains the specified key.
        /// </summary>
        public bool ContainsKey(string key) => _recordsByKey.ContainsKey(key);
        #endregion // Indexing by `Key`

        /// <summary>
        /// Read a table from specified file.
        /// </summary>
        public async Task ReadAsync(string filename)
        {
            var bytes = await Tables.ReadAllBytesAsync(filename);
            var reader = new LiteBinaryReader(bytes);
            await ReadAsync(reader);
        }

        /// <summary>
        /// Read a table from specified reader.
        /// </summary>
        public async Task ReadAsync(LiteBinaryReader reader)
        {
            uint version = 0;
            reader.Read(out version);

            byte flags = 0;
            reader.Read(out flags);

            int count = reader.ReadCounter32();
            for (int i = 0; i < count; i++)
            {
                var record = new Record();
                await record.ReadAsync(reader);
                _records.Add(record);
            }

            // Index mapping
            foreach (var record in _records)
                _recordsByIndex.Add(record.Index, record);
            foreach (var record in _records)
                _recordsByKey.Add(record.Key, record);
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            ToStringHelper.ToString(_records, sb);
            return sb.ToString();
        }
    }
    #endregion

    #region TestFieldTypesTable
    /// <summary>
    /// 필드 타입 테스트용 테이블입니다.
    /// </summary>
    [System.Serializable]
    public partial class TestFieldTypesTable
    {
        #region Record
        [System.Serializable]
        public partial class Record
        {
            #region Fields
            /// <summary>
            /// 인덱스(필수)
            /// </summary>
            public int Index => _index;
            private int _index;

            /// <summary>
            /// string field
            /// </summary>
            public string StringField => _stringField;
            private string _stringField;

            /// <summary>
            /// boolean field
            /// </summary>
            public bool BoolField => _boolField;
            private bool _boolField;

            /// <summary>
            /// 32 bit integer field
            /// </summary>
            public int IntField => _intField;
            private int _intField;

            /// <summary>
            /// float field
            /// </summary>
            public float FloatField => _floatField;
            private float _floatField;

            /// <summary>
            /// double field
            /// </summary>
            public double DoubleField => _doubleField;
            private double _doubleField;

            /// <summary>
            /// datetime field
            /// </summary>
            public System.DateTime DatetimeField => _datetimeField;
            private System.DateTime _datetimeField;

            /// <summary>
            /// timespan field
            /// </summary>
            public System.TimeSpan TimespanField => _timespanField;
            private System.TimeSpan _timespanField;

            /// <summary>
            /// uuid field
            /// </summary>
            public System.Guid UuidField => _uuidField;
            private System.Guid _uuidField;

            /// <summary>
            /// value type
            /// </summary>
            public global::StaticData.ValueType ValueType => _valueType;
            private global::StaticData.ValueType _valueType;
            #endregion

            #region Read record
            /// <summary>
            /// Reads a table record.
            /// </summary>
            public Task ReadAsync(LiteBinaryReader reader)
            {
                int tempEnumInt = 0;
                reader.Read(out _index);

                reader.Read(out _stringField);

                reader.Read(out _boolField);

                reader.Read(out _intField);

                reader.Read(out _floatField);

                reader.Read(out _doubleField);

                reader.Read(out _datetimeField);

                reader.Read(out _timespanField);

                reader.Read(out _uuidField);

                reader.ReadOptimalInt32(out tempEnumInt);
                _valueType = (global::StaticData.ValueType)tempEnumInt;

                return Task.CompletedTask;
            }
            #endregion

            #region ToString
            public override string ToString()
            {
                var sb = new StringBuilder("{");
                sb.Append("\"Index\":"); ToStringHelper.ToString(Index, sb);
                sb.Append(",\"StringField\":"); ToStringHelper.ToString(StringField, sb);
                sb.Append(",\"BoolField\":"); ToStringHelper.ToString(BoolField, sb);
                sb.Append(",\"IntField\":"); ToStringHelper.ToString(IntField, sb);
                sb.Append(",\"FloatField\":"); ToStringHelper.ToString(FloatField, sb);
                sb.Append(",\"DoubleField\":"); ToStringHelper.ToString(DoubleField, sb);
                sb.Append(",\"DatetimeField\":"); ToStringHelper.ToString(DatetimeField, sb);
                sb.Append(",\"TimespanField\":"); ToStringHelper.ToString(TimespanField, sb);
                sb.Append(",\"UuidField\":"); ToStringHelper.ToString(UuidField, sb);
                sb.Append(",\"ValueType\":"); ToStringHelper.ToString(ValueType, sb);
                sb.Append("}");
                return sb.ToString();
            }
            #endregion
        }
        #endregion

        /// <summary>
        /// Field names.
        /// </summary>
        public static readonly string[] FieldNames = { "Index", "StringField", "BoolField", "IntField", "FloatField", "DoubleField", "DatetimeField", "TimespanField", "UuidField", "ValueType" };

        /// <summary>
        /// Build object value map.
        /// </summary>
        public List<object[]> BuildObjectValueMap()
        {
            var result = new List<object[]>();
            foreach (var r in _records)
                result.Add(new object[] { r.Index, r.StringField, r.BoolField, r.IntField, r.FloatField, r.DoubleField, r.DatetimeField, r.TimespanField, r.UuidField, r.ValueType });

            return result;
        }

        /// <summary>
        /// All records.
        /// </summary>
        public List<Record> Records => _records;
        private readonly List<Record> _records = new List<Record>();

        #region Indexing by 'Index'
        public Dictionary<int, Record> RecordsByIndex => _recordsByIndex;
        private readonly Dictionary<int, Record> _recordsByIndex = new Dictionary<int, Record>();

        /// <summary>
        /// Gets the value associated with the specified key. throw SheetManException if not found.
        /// </summary>
        public Record GetByIndex(int key)
        {
            if (!TryGetByIndex(key, out Record record))
                throw new SheetManException($"There is no record in table `TestFieldTypes` that corresponds to field `Index` value {key}");

            return record;
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        public bool TryGetByIndex(int key, out Record result) => _recordsByIndex.TryGetValue(key, out result);

        /// <summary>
        /// Determines whether the table contains the specified key.
        /// </summary>
        public bool ContainsIndex(int key) => _recordsByIndex.ContainsKey(key);
        #endregion // Indexing by `Index`

        #region Indexing by 'StringField'
        public Dictionary<string, Record> RecordsByStringField => _recordsByStringField;
        private readonly Dictionary<string, Record> _recordsByStringField = new Dictionary<string, Record>();

        /// <summary>
        /// Gets the value associated with the specified key. throw SheetManException if not found.
        /// </summary>
        public Record GetByStringField(string key)
        {
            if (!TryGetByStringField(key, out Record record))
                throw new SheetManException($"There is no record in table `TestFieldTypes` that corresponds to field `StringField` value {key}");

            return record;
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        public bool TryGetByStringField(string key, out Record result) => _recordsByStringField.TryGetValue(key, out result);

        /// <summary>
        /// Determines whether the table contains the specified key.
        /// </summary>
        public bool ContainsStringField(string key) => _recordsByStringField.ContainsKey(key);
        #endregion // Indexing by `StringField`

        /// <summary>
        /// Read a table from specified file.
        /// </summary>
        public async Task ReadAsync(string filename)
        {
            var bytes = await Tables.ReadAllBytesAsync(filename);
            var reader = new LiteBinaryReader(bytes);
            await ReadAsync(reader);
        }

        /// <summary>
        /// Read a table from specified reader.
        /// </summary>
        public async Task ReadAsync(LiteBinaryReader reader)
        {
            uint version = 0;
            reader.Read(out version);

            byte flags = 0;
            reader.Read(out flags);

            int count = reader.ReadCounter32();
            for (int i = 0; i < count; i++)
            {
                var record = new Record();
                await record.ReadAsync(reader);
                _records.Add(record);
            }

            // Index mapping
            foreach (var record in _records)
                _recordsByIndex.Add(record.Index, record);
            foreach (var record in _records)
                _recordsByStringField.Add(record.StringField, record);
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            ToStringHelper.ToString(_records, sb);
            return sb.ToString();
        }
    }
    #endregion

    #region SerialFieldsTable
    /// <summary>
    /// 로컬라이제이션 테스트 테이블입니다.
    /// </summary>
    [System.Serializable]
    public partial class SerialFieldsTable
    {
        #region Record
        [System.Serializable]
        public partial class Record
        {
            #region Fields
            /// <summary>
            /// 인덱스(필수)
            /// </summary>
            public int Index => _index;
            private int _index;

            /// <summary>
            /// 영문 텍스트1
            /// </summary>
            public string[] TextEnArray => _textEnArray;
            public const int TextEnArray_N = 2;
            private string[] _textEnArray = new string[TextEnArray_N];
            #endregion

            #region Read record
            /// <summary>
            /// Reads a table record.
            /// </summary>
            public Task ReadAsync(LiteBinaryReader reader)
            {
                reader.Read(out _index);

                for (int i = 0; i < TextEnArray_N; ++i)
                {
                    reader.Read(out _textEnArray[i]);
                }

                return Task.CompletedTask;
            }
            #endregion

            #region ToString
            public override string ToString()
            {
                var sb = new StringBuilder("{");
                sb.Append("\"Index\":"); ToStringHelper.ToString(Index, sb);
                sb.Append(",\"TextEnArray\":"); ToStringHelper.ToString(TextEnArray, sb);
                sb.Append("}");
                return sb.ToString();
            }
            #endregion
        }
        #endregion

        /// <summary>
        /// Field names.
        /// </summary>
        public static readonly string[] FieldNames = { "Index", "TextEnArray" };

        /// <summary>
        /// Build object value map.
        /// </summary>
        public List<object[]> BuildObjectValueMap()
        {
            var result = new List<object[]>();
            foreach (var r in _records)
                result.Add(new object[] { r.Index, r.TextEnArray });

            return result;
        }

        /// <summary>
        /// All records.
        /// </summary>
        public List<Record> Records => _records;
        private readonly List<Record> _records = new List<Record>();

        #region Indexing by 'Index'
        public Dictionary<int, Record> RecordsByIndex => _recordsByIndex;
        private readonly Dictionary<int, Record> _recordsByIndex = new Dictionary<int, Record>();

        /// <summary>
        /// Gets the value associated with the specified key. throw SheetManException if not found.
        /// </summary>
        public Record GetByIndex(int key)
        {
            if (!TryGetByIndex(key, out Record record))
                throw new SheetManException($"There is no record in table `SerialFields` that corresponds to field `Index` value {key}");

            return record;
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        public bool TryGetByIndex(int key, out Record result) => _recordsByIndex.TryGetValue(key, out result);

        /// <summary>
        /// Determines whether the table contains the specified key.
        /// </summary>
        public bool ContainsIndex(int key) => _recordsByIndex.ContainsKey(key);
        #endregion // Indexing by `Index`

        /// <summary>
        /// Read a table from specified file.
        /// </summary>
        public async Task ReadAsync(string filename)
        {
            var bytes = await Tables.ReadAllBytesAsync(filename);
            var reader = new LiteBinaryReader(bytes);
            await ReadAsync(reader);
        }

        /// <summary>
        /// Read a table from specified reader.
        /// </summary>
        public async Task ReadAsync(LiteBinaryReader reader)
        {
            uint version = 0;
            reader.Read(out version);

            byte flags = 0;
            reader.Read(out flags);

            int count = reader.ReadCounter32();
            for (int i = 0; i < count; i++)
            {
                var record = new Record();
                await record.ReadAsync(reader);
                _records.Add(record);
            }

            // Index mapping
            foreach (var record in _records)
                _recordsByIndex.Add(record.Index, record);
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            ToStringHelper.ToString(_records, sb);
            return sb.ToString();
        }
    }
    #endregion

    #region Enums
    // Generated from https://docs.google.com/spreadsheets/d/10NXZAeyFaxRFsC8BPVTS9A6DzsM57Z1tizpJMCokJwU/edit#gid=918996371&range=B21
    /// <summary>
    /// 전투 상태에 관련된 enum 정의입니다.
    /// </summary>
    public enum ValueType
    {
        /// <summary>
        /// 알수 없는 타입
        /// </summary>
        None = 1,
        /// <summary>
        /// 32 bits integer
        /// </summary>
        Int = 2,
        /// <summary>
        /// 64 bits integer
        /// </summary>
        Bigint = 3,
        /// <summary>
        /// boolean
        /// </summary>
        Boolean = 4,
        /// <summary>
        /// floating point number
        /// </summary>
        Float = 5,
        /// <summary>
        /// double precise floating point number
        /// </summary>
        Double = 6,
        /// <summary>
        /// datetime
        /// </summary>
        Datetime = 7,
        /// <summary>
        /// timespan
        /// </summary>
        Timespan = 8,
        /// <summary>
        /// uuid
        /// </summary>
        Uuid = 9,
        /// <summary>
        /// enum
        /// </summary>
        Enum = 10,
        /// <summary>
        /// foregin table record
        /// </summary>
        Foreign = 11
    }

    /// <summary>
    /// Helper class for avoiding boxing as dictionary key.
    /// </summary>
    public struct ValueTypeComparer : IEqualityComparer<ValueType>
    {
        public bool Equals(ValueType x, ValueType y)
        {
            return x == y;
        }

        public int GetHashCode(ValueType obj)
        {
            return (int)obj;
        }
    }
    #endregion

    #region Helpers
    /// <summary>
    /// Exception about SheetMan.
    /// </summary>
    public class SheetManException : System.Exception
    {
        public SheetManException()
        {
        }

        public SheetManException(string message) : base(message)
        {
        }

        public SheetManException(string message, System.Exception inner) : base(message, inner)
        {
        }
    }

    /// <summary>
    /// Collection helper class.
    /// </summary>
    public static class CollectionsHelper
    {
        /// <summary>
        /// This will return true if the two collections are value-wise the same.
        /// If the collection contains a collection, the collections will be compared using this method.
        /// </summary>
        public static bool Equals(IEnumerable first, IEnumerable second)
        {
            if (first == null && second == null)
                return true;

            if (first == null || second == null)
                return false;

            var fiter = first.GetEnumerator();
            var siter = second.GetEnumerator();

            var fnext = fiter.MoveNext();
            var snext = siter.MoveNext();

            while (fnext && snext)
            {
                var fenum = fiter.Current as IEnumerable;
                var senum = siter.Current as IEnumerable;

                if (fenum != null && senum != null)
                {
                    if (!Equals(fenum, senum))
                        return false;
                }
                else if (fenum == null ^ senum == null)
                {
                    return false;
                }
                else if (!Equals(fiter.Current, siter.Current))
                {
                    return false;
                }

                fnext = fiter.MoveNext();
                snext = siter.MoveNext();
            }

            return fnext == snext;
        }

        /// <summary>
        /// This returns a hashcode based on the value of the enumerable.
        /// </summary>
        public static int GetHashCode(IEnumerable enumerable)
        {
            if (enumerable == null)
                return 0;

            int hashcode = 0;
            foreach (var item in enumerable)
            {
                int objHash = !(item is IEnumerable enumerableItem) ? item.GetHashCode() : GetHashCode(enumerableItem);

                unchecked
                {
                    hashcode = (hashcode * 397) ^ objHash;
                }
            }

            return hashcode;
        }
    }
    /// <summary>
    /// ToString helper class.
    /// </summary>
    public static class ToStringHelper
    {
        public static void ToString(object self, StringBuilder target, bool first = true)
        {
            if (!first)
                target.Append(", ");

            bool firstChild = true;
            if (self is string)
            {
                target.Append('"');
                target.Append(self);
                target.Append('"');
            }
            else if (self is IDictionary dictionary)
            {
                target.Append("{");
                foreach (DictionaryEntry pair in dictionary)
                {
                    if (firstChild)
                        firstChild = false;
                    else
                        target.Append(", ");

                    target.Append("{");
                    ToString(pair.Key, target, true);
                    target.Append(", ");
                    ToString(pair.Value, target, true);
                    target.Append("}");
                }
                target.Append("}");
            }
            else if (self is IEnumerable enumerable)
            {
                target.Append("[");
                foreach (var element in enumerable)
                {
                    ToString(element, target, firstChild);
                    firstChild = false;
                }
                target.Append("]");
            }
            else
            {
                target.Append(self);
            }
        }
    }
    #endregion

} // namespace StaticData

