// ------------------------------------------------------------------------------
// <auto-generated>
//     THIS CODE WAS GENERATED BY SheetMan.
//
//     CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
//     THE CODE IS REGENERATED.
// </auto-generated>
// ------------------------------------------------------------------------------

import * as fs from 'fs'

/** A type for handling rows when parsing .json. */
interface IDataRow {
    index: number
    textEnArray: string[]
}

// Generated from https://docs.google.com/spreadsheets/d/10NXZAeyFaxRFsC8BPVTS9A6DzsM57Z1tizpJMCokJwU/edit#gid=921991335&range=B3
/** 로컬라이제이션 테스트 테이블입니다. */
export class SerialFieldsRecord {
    /** Default constructor */
    constructor() {
    }

    /** 인덱스(필수) */
    public get index(): number { return this._index }
    private _index: number

    /** 영문 텍스트1 */
    public get textEnArray(): string[] { return this._textEnArray }
    public static readonly textEnArray_N = 2
    private _textEnArray: string[]

    /** Populate field values. */
    public populateFieldValues(dataRow: IDataRow): void {
        this._index = dataRow.index
        this._textEnArray = dataRow.textEnArray
    }

    /** Populate field values. */
    public populateFieldValuesCompact(dataRow: any[]): void {
        let offset = 0
        this._index = dataRow[offset++]
        this._textEnArray = dataRow[offset++]
    }
}

// Generated from https://docs.google.com/spreadsheets/d/10NXZAeyFaxRFsC8BPVTS9A6DzsM57Z1tizpJMCokJwU/edit#gid=921991335&range=B3
/** 로컬라이제이션 테스트 테이블입니다. */
export class SerialFieldsTable {
    /** Default constructor. */
    constructor() {
    }

    /** All records. */
    public get records(): SerialFieldsRecord[] { return this._records }
    private _records: SerialFieldsRecord[] = []

    // Indexing by 'index'
    public get recordsByIndex(): Map<number, SerialFieldsRecord> { return this._recordsByIndex }
    private _recordsByIndex: Map<number, SerialFieldsRecord> = new Map<number, SerialFieldsRecord>()

    /** Gets the value associated with the specified key. throw Error if not found. */
    public getByIndex(key: number): SerialFieldsRecord {
        const found = this._recordsByIndex.get(key)
        if (!found)
            throw new Error(`There is no record in table "SerialFields" that corresponds to field "index" value ${key}`)

        return found
    }

    /** Gets the value associated with the specified key. */
    public tryGetByIndex(key: number): SerialFieldsRecord | undefined {
        return this._recordsByIndex.get(key)
    }

    /** Determines whether the table contains the specified key. */
    public containsIndex(key: number): boolean {
        return !!this._recordsByIndex.has(key)
    }

    /** Read a table from specified file. */
    public async read(filename: string): Promise<void> {
        const json = await fs.promises.readFile(filename, "utf8")
        this.readFromJson(json)
    }

    /** Read a table from specified file synchronously. */
    public readSync(filename: string): void {
        const json = fs.readFileSync(filename, "utf8")
        this.readFromJson(json)
    }

    private readFromJson(json: string): void {
        const dataRows: any[] = JSON.parse(json)
        if (this.isCompactRowFormatted(dataRows)) {
            for (const dataRow of dataRows) {
                const record = new SerialFieldsRecord()
                record.populateFieldValuesCompact(dataRow)
                this._records.push(record)
            }
        } else {
            for (const dataRow of dataRows as IDataRow[]) {
                const record = new SerialFieldsRecord()
                record.populateFieldValues(dataRow)
                this._records.push(record)
            }
        }

        this.mapping()
    }

    private isCompactRowFormatted(rows: any[]): boolean {
        return rows.length > 0 && Array.isArray(rows[0])
    }

    /** Index mapping. */
    private mapping(): void {
        for (const record of this._records)
            this._recordsByIndex.set(record.index, record);
    }
}

