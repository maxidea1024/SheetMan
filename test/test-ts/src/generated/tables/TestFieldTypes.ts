// ------------------------------------------------------------------------------
// <auto-generated>
//     THIS CODE WAS GENERATED BY SheetMan.
//
//     CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
//     THE CODE IS REGENERATED.
// </auto-generated>
// ------------------------------------------------------------------------------

import * as fs from 'fs'

// Automatically import to handle external type references.
import { ValueType } from '../enums/ValueType'

/** A type for handling rows when parsing .json. */
interface IDataRow {
    index: number
    stringField: string
    boolField: boolean
    intField: number
    floatField: number
    doubleField: number
    datetimeField: string
    timespanField: string
    uuidField: string
    valueType: ValueType
}

// Generated from https://docs.google.com/spreadsheets/d/10NXZAeyFaxRFsC8BPVTS9A6DzsM57Z1tizpJMCokJwU/edit#gid=918996371&range=B2
/** 필드 타입 테스트용 테이블입니다. */
export class TestFieldTypesRecord {
    /** Default constructor */
    constructor() {
    }

    /** 인덱스(필수) */
    public get index(): number { return this._index }
    private _index: number

    /** string field */
    public get stringField(): string { return this._stringField }
    private _stringField: string

    /** boolean field */
    public get boolField(): boolean { return this._boolField }
    private _boolField: boolean

    /** 32 bit integer field */
    public get intField(): number { return this._intField }
    private _intField: number

    /** float field */
    public get floatField(): number { return this._floatField }
    private _floatField: number

    /** double field */
    public get doubleField(): number { return this._doubleField }
    private _doubleField: number

    /** datetime field */
    public get datetimeField(): string { return this._datetimeField }
    private _datetimeField: string

    /** timespan field */
    public get timespanField(): string { return this._timespanField }
    private _timespanField: string

    /** uuid field */
    public get uuidField(): string { return this._uuidField }
    private _uuidField: string

    /** value type */
    public get valueType(): ValueType { return this._valueType }
    private _valueType: ValueType

    /** Populate field values. */
    public populateFieldValues(dataRow: IDataRow): void {
        this._index = dataRow.index
        this._stringField = dataRow.stringField
        this._boolField = dataRow.boolField
        this._intField = dataRow.intField
        this._floatField = dataRow.floatField
        this._doubleField = dataRow.doubleField
        this._datetimeField = dataRow.datetimeField
        this._timespanField = dataRow.timespanField
        this._uuidField = dataRow.uuidField
        this._valueType = dataRow.valueType
    }

    /** Populate field values. */
    public populateFieldValuesCompact(dataRow: any[]): void {
        let offset = 0
        this._index = dataRow[offset++]
        this._stringField = dataRow[offset++]
        this._boolField = dataRow[offset++]
        this._intField = dataRow[offset++]
        this._floatField = dataRow[offset++]
        this._doubleField = dataRow[offset++]
        this._datetimeField = dataRow[offset++]
        this._timespanField = dataRow[offset++]
        this._uuidField = dataRow[offset++]
        this._valueType = dataRow[offset++]
    }
}

// Generated from https://docs.google.com/spreadsheets/d/10NXZAeyFaxRFsC8BPVTS9A6DzsM57Z1tizpJMCokJwU/edit#gid=918996371&range=B2
/** 필드 타입 테스트용 테이블입니다. */
export class TestFieldTypesTable {
    /** Default constructor. */
    constructor() {
    }

    /** All records. */
    public get records(): TestFieldTypesRecord[] { return this._records }
    private _records: TestFieldTypesRecord[] = []

    // Indexing by 'index'
    public get recordsByIndex(): Map<number, TestFieldTypesRecord> { return this._recordsByIndex }
    private _recordsByIndex: Map<number, TestFieldTypesRecord> = new Map<number, TestFieldTypesRecord>()

    /** Gets the value associated with the specified key. throw Error if not found. */
    public getByIndex(key: number): TestFieldTypesRecord {
        const found = this._recordsByIndex.get(key)
        if (!found)
            throw new Error(`There is no record in table "TestFieldTypes" that corresponds to field "index" value ${key}`)

        return found
    }

    /** Gets the value associated with the specified key. */
    public tryGetByIndex(key: number): TestFieldTypesRecord | undefined {
        return this._recordsByIndex.get(key)
    }

    /** Determines whether the table contains the specified key. */
    public containsIndex(key: number): boolean {
        return !!this._recordsByIndex.has(key)
    }

    // Indexing by 'stringField'
    public get recordsByStringField(): Map<string, TestFieldTypesRecord> { return this._recordsByStringField }
    private _recordsByStringField: Map<string, TestFieldTypesRecord> = new Map<string, TestFieldTypesRecord>()

    /** Gets the value associated with the specified key. throw Error if not found. */
    public getByStringField(key: string): TestFieldTypesRecord {
        const found = this._recordsByStringField.get(key)
        if (!found)
            throw new Error(`There is no record in table "TestFieldTypes" that corresponds to field "stringField" value ${key}`)

        return found
    }

    /** Gets the value associated with the specified key. */
    public tryGetByStringField(key: string): TestFieldTypesRecord | undefined {
        return this._recordsByStringField.get(key)
    }

    /** Determines whether the table contains the specified key. */
    public containsStringField(key: string): boolean {
        return !!this._recordsByStringField.has(key)
    }

    /** Read a table from specified file. */
    public async read(filename: string): Promise<void> {
        const json = await fs.promises.readFile(filename, "utf8")
        this.readFromJson(json)
    }

    /** Read a table from specified file synchronously. */
    public readSync(filename: string): void {
        const json = fs.readFileSync(filename, "utf8")
        this.readFromJson(json)
    }

    private readFromJson(json: string): void {
        const dataRows: any[] = JSON.parse(json)
        if (this.isCompactRowFormatted(dataRows)) {
            for (const dataRow of dataRows) {
                const record = new TestFieldTypesRecord()
                record.populateFieldValuesCompact(dataRow)
                this._records.push(record)
            }
        } else {
            for (const dataRow of dataRows as IDataRow[]) {
                const record = new TestFieldTypesRecord()
                record.populateFieldValues(dataRow)
                this._records.push(record)
            }
        }

        this.mapping()
    }

    private isCompactRowFormatted(rows: any[]): boolean {
        return rows.length > 0 && Array.isArray(rows[0])
    }

    /** Index mapping. */
    private mapping(): void {
        for (const record of this._records)
            this._recordsByIndex.set(record.index, record);
        for (const record of this._records)
            this._recordsByStringField.set(record.stringField, record);
    }
}

